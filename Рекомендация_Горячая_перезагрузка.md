
---

# Что происходит (кратко)

* FastAPI сохраняет новые промпты → **в своём процессе** перезагружает агента.
* Обработчик звонков (отдельный процесс) продолжает жить **со старыми** промптами → потому что он их загрузил при старте и больше не перечитывает.

---

# Цель

Сделать **кросс-процессный hot-reload**: любой процесс, который использует промпты, сам подхватывает обновления файла **без рестарта**.

---

# Подход (надёжный и простой)

1. **Атомарная запись** `prompts.json` в FastAPI: пишем во временный файл, `fsync`, `rename` → никакого «полу-файла».
2. **Воркер авто-перезагрузки** в обработчике звонков (и/или внутри `Agent`): периодически проверяет `mtime` файла и, если изменился, вызывает `agent.reload_prompts()`.

> Работает на любом окружении, не требует Redis/сообщений/сигналов. Можно включить/выключить через `.env`.

---

# Мини-патч (unified diff)

## 1) `.env` — параметры горячей замены

```diff
*** /dev/null
--- a/env.example
***************
+############################
+# Prompts hot reload
+############################
+PROMPTS_PATH=./prompts.json
+PROMPTS_RELOAD_INTERVAL_MS=1500   # период проверки mtime
+PROMPTS_HOT_RELOAD=true           # флаг включения
```

---

## 2) `agent.py` — загрузка + безопасный перезагрузчик

```diff
--- a/agent.py
+++ b/agent.py
@@
+import os, json, time, threading
+
 class Agent:
     def __init__(self, *args, **kwargs):
-        self.prompts = self.load_prompts()
+        self.prompts_path = os.getenv("PROMPTS_PATH", "./prompts.json")
+        self.prompts = self._load_prompts_from_file(self.prompts_path)
+        self._prompts_mtime = self._get_mtime(self.prompts_path)
+        self._hot_reload = os.getenv("PROMPTS_HOT_RELOAD", "true").lower() == "true"
+        self._reload_interval = int(os.getenv("PROMPTS_RELOAD_INTERVAL_MS", "1500")) / 1000.0
+        if self._hot_reload:
+            t = threading.Thread(target=self._watch_prompts_loop, daemon=True)
+            t.start()
@@
-    def load_prompts(self):
-        # старая реализация
-        ...
+    def _get_mtime(self, path: str) -> float:
+        try:
+            return os.path.getmtime(path)
+        except Exception:
+            return -1.0
+
+    def _load_prompts_from_file(self, path: str) -> dict:
+        with open(path, "r", encoding="utf-8") as f:
+            return json.load(f)
+
+    def reload_prompts(self) -> None:
+        """Явная перезагрузка (можно вызвать из FastAPI, если процессы совпадают)."""
+        self.prompts = self._load_prompts_from_file(self.prompts_path)
+        self._prompts_mtime = self._get_mtime(self.prompts_path)
+
+    def _watch_prompts_loop(self):
+        """Фоновый поток: следит за mtime файла и вызывает reload_prompts()."""
+        while True:
+            try:
+                m = self._get_mtime(self.prompts_path)
+                if m > 0 and m != self._prompts_mtime:
+                    self.reload_prompts()
+            except Exception:
+                pass
+            time.sleep(self._reload_interval)
```

---

## 3) `stasis_handler_optimized.py` — защита на случай, если агент создан здесь

```diff
--- a/stasis_handler_optimized.py
+++ b/stasis_handler_optimized.py
@@
 import os, asyncio, logging
@@
 class StasisHandlerOptimized:
     def __init__(self, ari, parallel_tts, filler_tts, asr, agent, log_store):
         self.agent = agent
+        # Если агент создан в этом процессе, он уже сам следит за prompts.json через поток.
+        # Ничего больше делать не нужно.
         ...
```

*(ничего менять в логике не требуется — авто-перезагрузка уже внутри `Agent`)*

---

## 4) `main.py` (FastAPI) — атомарная запись `prompts.json`

```diff
--- a/main.py
+++ b/main.py
@@
+import os, json, tempfile
@@
-@app.post("/api/prompts")
-async def update_prompts(payload: PromptsUpdatePayload):
-    with open(prompts_file, 'w', encoding='utf-8') as f:
-        json.dump(payload.dict(), f, ensure_ascii=False, indent=2)
-    if agent and hasattr(agent, 'reload_prompts'):
-        agent.reload_prompts()
-    return {"ok": True}
+@app.post("/api/prompts")
+async def update_prompts(payload: PromptsUpdatePayload):
+    data = payload.dict()
+    target = os.getenv("PROMPTS_PATH", "./prompts.json")
+    # 1) атомарная запись
+    dir_ = os.path.dirname(target) or "."
+    os.makedirs(dir_, exist_ok=True)
+    with tempfile.NamedTemporaryFile("w", delete=False, dir=dir_, prefix=".prompts.", suffix=".tmp", encoding="utf-8") as tf:
+        json.dump(data, tf, ensure_ascii=False, indent=2)
+        tf.flush()
+        os.fsync(tf.fileno())
+        tmp_path = tf.name
+    os.replace(tmp_path, target)  # атомарный rename
+    # 2) локальный процесс может перезагрузиться немедленно (если агент тут живёт)
+    try:
+        if agent and hasattr(agent, 'reload_prompts'):
+            agent.reload_prompts()
+    except Exception:
+        pass
+    return {"ok": True}
```

---

# Как это будет работать

* При любом изменении `prompts.json` (через панель/ручной апдейт) процессы, в которых запущен `Agent`, **автоматически** заметят смену `mtime` и вызовут `reload_prompts()`.
* Атомарная запись гарантирует, что «читающий» процесс всегда увидит целостный JSON (никаких полупустых файлов).

---

# Быстрый чек-лист

1. Обнови `.env`(смотри чтобы соответсвовало некущему проекту и путям):

```
PROMPTS_PATH=./prompts.json
PROMPTS_RELOAD_INTERVAL_MS=1500
PROMPTS_HOT_RELOAD=true
```

2. Применяй патчи, перезапусти сервисы один раз (чтобы загрузился фон. поток).
3. Меняй промпты → шли запрос/звонок → бот должен отвечать уже по новым.
4. Если хочешь выключить hot-reload (для A/B): `PROMPTS_HOT_RELOAD=false`.

---

