---

# A. Контекст и мои обращения (что именно нужно исправить)

1. **Бот “обрывает” мою речь** даже без пауз: я говорю длинно и непрерывно, а запись прекращается и уходит в обработку слишком рано.
2. **Barge-in встроен, но не работает корректно**: попытки включить приводили к рассинхрону (старые TTS-потоки не глушатся мгновенно, ответ “налезает”).
3. (Ранее) **Филлеры видно в логах, но не слышно** — решено позже; сейчас низкий приоритет.
4. (Ранее) **Иногда вызов “сам” завершался** — у кода был жёсткий таймаут бездействия; нужно выносить в `.env`.

Цель: **минимальная задержка ответа и при этом бот должен дослушивать пользователя**; barge-in — мгновенный и без рассинхрона.

---

# B. Картина текущей архитектуры (важно для агента)

* **Исходящий голос (бот → абонент)**: уже реализован **chunked TTS** + параллельный проигрыватель (`parallel_tts.py`).
* **Входящий голос (абонент → бот)**: пока классический **VAD→WAV→ASR**: запись *одним файлом* до тишины или до лимита `VAD_MAX_RECORDING_TIME`, затем отправка в ASR. **Стриминга/чанкования входящей речи нет.** Это и “режет” длинные монологи.
* **Barge-in**: логика вызова есть (очистка очередей), но **нет гарантированного гашения всех активных ARI-playbacks** у Asterisk.

---

# C. План работ (таск-лист для Cursor-агента)

1. **[ВХОД] Добавить “мягкое окно” для записи речи кусками без остановки записи** (квазистрим):

   * `simple_vad_service.py`: новая функция `record_until_silence_with_soft_window(...)`.
   * `stasis_handler_optimized.py`: обработка `on_chunk`, накопление текста, опциональный префетч.

2. **[ВХОД] Ослабить преждевременные обрывы записи**:

   * `.env`: поднять `VAD_MAX_RECORDING_TIME` (12–15s), `VAD_SILENCE_TIMEOUT=2.0`, синхронизировать `SPEECH_SILENCE_TIMEOUT=2.0`, `SPEECH_MIN_DURATION=0.6–0.8`.

3. **[ВЫХОД] Починить barge-in на уровне ARI**:

   * `ari_client.py`: метод `stop_playback(playback_id)` (DELETE /playbacks/{id}).
   * `stasis_handler_optimized.py`: в `stop_tts_on_barge_in_optimized(...)` — остановить *все* активные playbacks (по реестру), считать `404/409` успехом.

4. **[ЖИЗНЕННЫЙ ЦИКЛ ЗВОНКА] Вынести таймауты в .env**:

   * `CALL_INACTIVITY_TIMEOUT`, `CHANNEL_MONITOR_INTERVAL` — заменить “магические 30s”.

5. **(Опционально) Prefetch** ответа по частичным результатам:

   * В `_handle_user_speech` начать запрос к агенту после 1–2 кусочков, чтобы сократить паузу.

6. **(Опционально) Asterisk-тюнинг для низкой задержки**:

   * `rtp.conf`: отключить лишний джиттер-буфер на стороне Asterisk, т.п.
   * использовать прямое воспроизведение на канал, не через bridge (если текущее — через bridge), или при бардж-ине пересоздавать bridge.

---

# D. Готовые правки (код, без заглушек)

## D1) `.env` — новые и обновлённые параметры

```env
# --- VAD / SmartDetector: слух абонента ---
VAD_SILENCE_TIMEOUT=2.0          # было 1.2
VAD_MIN_RECORDING_TIME=1.0       # было 1.5
VAD_MAX_RECORDING_TIME=15.0      # было 6.0 (оставляем как общий предохранитель)
SPEECH_SILENCE_TIMEOUT=2.0       # было 1.2
SPEECH_MIN_DURATION=0.6          # 0.6–0.8 оптимально
INPUT_DEBOUNCE_MS=1000           # было 1200 (субъективно живее)
BARGE_IN_GUARD_MS=300            # было 400 (перебить бота чуть легче)

# --- “Мягкое окно” для длинной речи ---
CHUNK_STREAMING_SECONDS=5
CHUNK_OVERLAP_MS=150
MAX_UTTERANCE_SECONDS=60         # общий предохранитель всей реплики

# --- Жизненный цикл звонка ---
CALL_INACTIVITY_TIMEOUT=180      # вместо зашитых 30 секунд
CHANNEL_MONITOR_INTERVAL=60
```

> Если раньше был дубликат `SPEECH_MAX_RECORDING_TIME=8.0` — удалить, чтобы код не брал “короткий” лимит.

---

## D2) `simple_vad_service.py` — “квазистрим”: запись кусками без остановки

Добавьте **новый** метод (существующие не ломаем):

```python
# simple_vad_service.py
import os, wave, time
from time import monotonic

class SimpleVADService:
    def __init__(self, logger, ...):
        self.logger = logger
        self.silence_timeout = float(os.getenv("VAD_SILENCE_TIMEOUT", "2.0"))
        self.min_rec_time    = float(os.getenv("VAD_MIN_RECORDING_TIME", "1.0"))
        # Предохранитель всей реплики:
        self.max_utt_time    = float(os.getenv("MAX_UTTERANCE_SECONDS", "60.0"))
        # “Мягкое окно” (длина одного куска):
        self.chunk_secs      = float(os.getenv("CHUNK_STREAMING_SECONDS", "5"))
        self.chunk_overlap   = int(os.getenv("CHUNK_OVERLAP_MS", "150"))

    async def record_until_silence_with_soft_window(self, channel_id: str, on_chunk):
        """
        Записывает длинную речь кусками, не останавливая запись:
        - on_chunk(path, is_final, index): синхронно/асинхронно отправляет WAV в ASR
        - is_final=True выставляется при реальной тишине или при max_utt_time
        """
        start_ts   = monotonic()
        index      = 0
        last_voice = monotonic()
        deadline   = monotonic() + self.chunk_secs

        wav = self._start_new_wav(channel_id, index)

        while True:
            frame = await self._read_audio_frame()  # ваш источник PCM (20–30мс)
            if frame is None:
                break

            self._write_pcm(wav, frame)
            now = monotonic()

            if self._is_speech(frame):
                last_voice = now

            # 1) Тишина достаточной длительности → финал всей реплики
            if (now - last_voice) >= self.silence_timeout and (now - start_ts) >= self.min_rec_time:
                path = self._finalize_wav(wav)
                try:
                    await on_chunk(path, True, index)   # final
                finally:
                    self._close(wav)
                return

            # 2) Истёк “кусок окна” → закрываем partial и продолжаем запись
            if now >= deadline:
                path = self._finalize_wav(wav)
                try:
                    await on_chunk(path, False, index)  # partial
                finally:
                    self._close(wav)

                index += 1
                wav = self._start_new_wav(channel_id, index, overlap_ms=self.chunk_overlap)
                deadline = monotonic() + self.chunk_secs

            # 3) Общий предохранитель
            if (now - start_ts) >= self.max_utt_time:
                path = self._finalize_wav(wav)
                try:
                    await on_chunk(path, True, index)   # final
                finally:
                    self._close(wav)
                return

    # --- Ниже утилиты записи WAV: используйте ваши готовые реализации ---
    def _start_new_wav(self, channel_id: str, index: int, overlap_ms: int = 0):
        # открыть файл WAV на запись (8kHz mono LINEAR16)
        # при overlap_ms можно продублировать последние N мс предыдущего буфера, если вы храните PCM-кольцевой буфер
        ...
    def _write_pcm(self, wav, frame_bytes: bytes):
        ...
    def _finalize_wav(self, wav) -> str:
        # закрыть файл и вернуть путь
        ...
    def _close(self, wav):
        ...
    def _read_audio_frame(self) -> bytes:
        # получить очередной фрейм из канала/потока
        ...
    def _is_speech(self, frame: bytes) -> bool:
        # ваш текущий VAD-критерий: Энергия/РМС/бинарный детектор
        ...
```

> Этот метод **не прерывает запись** на границе куска — он её логически “режет” на последовательные WAV-файлы и отдаёт их в `on_chunk`. Так вы получаете “стрим-эффект” с минимальной задержкой **без** перехода на WS-стрим ASR.

---

## D3) `stasis_handler_optimized.py` — приём кусочков, накопление текста, префетч

В месте, где вы сейчас делаете обычную запись → замените на вызов “мягкого окна”:

```python
# stasis_handler_optimized.py (фрагмент)
async def _handle_user_speech(self, channel_id: str):
    agg = []  # копим текст кусочков
    first_prefetch_done = False

    async def on_chunk(path: str, is_final: bool, index: int):
        text = await self.asr.recognize_file(path)  # ваш текущий клиент Yandex STT (HTTP)
        if text:
            agg.append(text)
            self.logger.info(f"[ASR] chunk#{index} ({'final' if is_final else 'partial'}): {text}")

        # Префетч логики агента после 1–2 кусочков (ускоряет ответ)
        if not is_final and not first_prefetch_done and len(" ".join(agg)) > 20:
            first_prefetch_done = True
            asyncio.create_task(self.agent.prefetch(channel_id, " ".join(agg)))

    # Запись длинной реплики “квазистримом”
    await self.vad.record_until_silence_with_soft_window(channel_id, on_chunk)

    user_text = " ".join(agg).strip()
    if not user_text:
        return

    # Обычная логика ответа: здесь можете забрать результат префетча
    await self._answer_user(channel_id, user_text)
```

---

## D4) `ari_client.py` — гарантированная остановка воспроизведения

Добавьте метод (если ещё нет) и **используйте его в barge-in**:

```python
# ari_client.py (фрагмент)
class AsteriskARIClient:
    ...
    async def stop_playback(self, playback_id: str) -> bool:
        url = f"{self.base_url}/playbacks/{playback_id}"
        async with self.session.delete(url, auth=self.auth, timeout=self.timeout) as resp:
            # 200/204 => stopped; 404/409 считаем успехом (идемпотентно)
            return resp.status in (200, 204, 404, 409)
```

---

## D5) `stasis_handler_optimized.py` — barge-in гасит *все* playbacks

В вашей функции `stop_tts_on_barge_in_optimized(...)` **остановите “текущий” и все незавершённые**:

```python
# stasis_handler_optimized.py (фрагмент)
async def stop_tts_on_barge_in_optimized(self, channel_id: str, event_name: str):
    self.logger.info(f"🚫 [BARGE-IN] {event_name} → stop all playbacks & queues (ch={channel_id})")

    call = self.active_calls.get(channel_id, {})

    # 1) Текущий playback
    current = call.get("current_playback")
    if current:
        try:
            ok = await self.ari.stop_playback(current)
            if ok:
                self.logger.info(f"🛑 Stopped current playback: {current}")
        except Exception as e:
            self.logger.warning(f"stop_playback error for {current}: {e}")
        finally:
            call["current_playback"] = None
            self.active_calls[channel_id] = call

    # 2) Все активные playbacks из реестра событий
    active_pids = [pid for pid, meta in self.playback_events.items()
                   if meta.get("channel_id") == channel_id and not meta.get("finished", True)]
    for pid in active_pids:
        try:
            ok = await self.ari.stop_playback(pid)
            if ok:
                self.logger.info(f"🛑 Force stopped playback: {pid}")
            self.playback_events[pid]["finished"] = True
        except Exception as e:
            self.logger.warning(f"stop_playback error for {pid}: {e}")

    # 3) Очереди TTS/задачи
    if self.parallel_tts:
        await self.parallel_tts.clear_all_queues(channel_id)

    # 4) Флаги
    call["user_interrupted"] = True
    call["is_speaking"] = False
    self.active_calls[channel_id] = call
    self.logger.info("✅ Barge-in completed — ready for new input")
```

> Обязательно убедитесь, что вы **подписаны и обрабатываете** события `PlaybackStarted/PlaybackFinished` и пополняете `self.playback_events` (реестр нужен для п.2).

---

## D6) Таймауты звонка — вынести из “магических 30s”

В местах, где стартует/сбрасывается таймер:

```python
# stasis_handler_optimized.py (фрагмент)
import os
CALL_INACTIVITY_TIMEOUT = int(os.getenv("CALL_INACTIVITY_TIMEOUT", "180"))
CHANNEL_MONITOR_INTERVAL = int(os.getenv("CHANNEL_MONITOR_INTERVAL", "60"))

async def _start_call_timeout(self, channel_id: str):
    # вместо sleep(30) используем CALL_INACTIVITY_TIMEOUT
    ...

async def _monitor_channels(self):
    while True:
        await asyncio.sleep(CHANNEL_MONITOR_INTERVAL)
        # двойная проверка статусов канала, прежде чем вешать трубку
        ...
```

---

# E. (Опционально) Asterisk конфиг для низкой задержки

**`/etc/asterisk/rtp.conf`**

```ini
[general]
rtpstart=10000
rtpend=20000
jitterbuffer=no
rtp_timeout=30
rtp_timeout_hold=60
rtp_keepalive=20
```

**`/etc/asterisk/asterisk.conf`**

```ini
[options]
transmit_silence=no
```

Если TTS играет через **bridge**, а при barge-in DELETE по playback’ам оставляет “хвосты”, используйте “жёсткий” сценарий: **удаление bridge и пересоздание** (для мгновенного сброса буферов), затем вернуть канал в новый bridge.

---

# F. (Опционально) Тонкая настройка Yandex STT

Если используете HTTP-распознавание с параметрами, добавьте:

* `max_pause_between_words_hint_ms = 2000` — допускает паузы до 2.0s между словами без “ложного конца”.
* `eou_classifier_options = HIGH` — более “терпимый” к тишине (подбирается экспериментально).

> Это **дополняет** наш VAD/SmartDetector и снижает шанс “ложного” EOU на стороне ASR.

---

# G. Чек-лист тестирования (перед выкладкой)

1. **Короткая реплика “Да/Нет”** → улетает в обработку без задержек.
2. **Длинная речь 20–30s без пауз** → режется на 5s-чанки, каждый уходит в ASR; в конце — финал, ответ бота **без потери хвоста**.
3. **Barge-in**: во время TTS скажи “секундочку” → в логах `🛑 Stopped ...`, звук бота обрывается **мгновенно**, запись пользователя стартует.
4. **Таймаут звонка**: простаивай 2–3 минуты → авторазрыв должен сработать не ранее `CALL_INACTIVITY_TIMEOUT`.
5. **Сценарий шум/микропаузы**: с паузами ~1.5–2.0s бот **не должен** преждевременно завершать запись.

---

Если хочешь, соберу это в **единый `.patch`** (unified diff) к твоим файлам (`simple_vad_service.py`, `stasis_handler_optimized.py`, `ari_client.py`) + пример `.env`. Тогда ты сможешь просто применить патч в Cursor и протестировать.

____
___



**Вопрос:** «Дай финальный diff-пакет: идемпотентный barge-in + “мягкое окно” (квазистрим) для входящего аудио + env-параметры. Без заглушек, чтобы агент IDE сразу применил».

Ок — ниже единый набор минимальных правок. Формат — unified diff. Применяй через `git apply`.

---

# 1) `env.example` — новые/обновлённые параметры (создаём файл, если нет)

```diff
*** /dev/null
--- a/env.example
***************
+############################
+# Voice In (VAD / Smart)  #
+############################
+VAD_SILENCE_TIMEOUT=2.0
+VAD_MIN_RECORDING_TIME=1.0
+VAD_MAX_RECORDING_TIME=15.0
+
+SPEECH_SILENCE_TIMEOUT=2.0
+SPEECH_MIN_DURATION=0.6
+
+# Плавность входа
+INPUT_DEBOUNCE_MS=1000
+BARGE_IN_GUARD_MS=300
+
+############################
+# Soft window (quasi-stream)
+############################
+# Размер одного куска входящей речи (сек)
+CHUNK_STREAMING_SECONDS=5
+# Перекрытие между кусками (мс) для устойчивой склейки
+CHUNK_OVERLAP_MS=150
+# Общий предохранитель всей реплики (сек)
+MAX_UTTERANCE_SECONDS=60
+# Включение “мягкого окна”
+USE_SOFT_WINDOW_INPUT=true
+
+############################
+# Call lifecycle
+############################
+CALL_INACTIVITY_TIMEOUT=180
+CHANNEL_MONITOR_INTERVAL=60
+
+############################
+# Barge-in
+############################
+BARGE_IN_ENABLED=true
```

> Если у тебя есть `.env` — синхронизируй значения с этим шаблоном (удали дубликаты типа `SPEECH_MAX_RECORDING_TIME=8.0`).

---

# 2) `ari_client.py` — идемпотентная остановка воспроизведения

```diff
--- a/ari_client.py
+++ b/ari_client.py
@@
 class AsteriskARIClient:
@@
     async def play_sound(self, channel_id: str, media_uri: str) -> str:
         """
         Воспроизводит звук на канале. Возвращает playback_id.
         """
         # ... существующий код ...
         return playback_id
+
+    async def stop_playback(self, playback_id: str) -> bool:
+        """
+        Жёстко и идемпотентно останавливает активное проигрывание.
+        DELETE /playbacks/{playbackId}
+        """
+        url = f"{self.base_url}/playbacks/{playback_id}"
+        async with self.session.delete(url, auth=self.auth, timeout=self.timeout) as resp:
+            # считаем успехом 200/204 и гонки 404/409
+            return resp.status in (200, 204, 404, 409)
```

---

# 3) `simple_vad_service.py` — “мягкое окно” (квазистрим) для входящего аудио

```diff
--- a/simple_vad_service.py
+++ b/simple_vad_service.py
@@
+import os
+from time import monotonic
@@
 class SimpleVADService:
     def __init__(self, logger, *args, **kwargs):
         self.logger = logger
-        self.silence_timeout = 1.2
-        self.min_rec_time = 1.5
-        self.max_rec_time = 6.0
+        # читаем актуальные настройки из env
+        self.silence_timeout = float(os.getenv("VAD_SILENCE_TIMEOUT", "2.0"))
+        self.min_rec_time    = float(os.getenv("VAD_MIN_RECORDING_TIME", "1.0"))
+        # предохранитель “всей реплики” (сек)
+        self.max_utt_time    = float(os.getenv("MAX_UTTERANCE_SECONDS", "60"))
+        # мягкое окно (длина одного куска)
+        self.chunk_secs      = float(os.getenv("CHUNK_STREAMING_SECONDS", "5"))
+        self.chunk_overlap   = int(os.getenv("CHUNK_OVERLAP_MS", "150"))
@@
     async def record_until_silence(self, channel_id: str) -> str:
         """
         Старая реализация — запись одним файлом до тишины/потолка.
         Возвращает путь к WAV.
         """
         # ... существующий код ...
         return wav_path
+
+    async def record_until_silence_with_soft_window(self, channel_id: str, on_chunk):
+        """
+        Новая реализация: длинная речь режется на куски фиксированной длины,
+        при этом запись НЕ останавливается на границе куска.
+        on_chunk(path, is_final, index) — ваш колбэк: отправляет WAV в ASR.
+        """
+        start_ts   = monotonic()
+        index      = 0
+        last_voice = monotonic()
+        deadline   = monotonic() + self.chunk_secs
+
+        wav = self._start_new_wav(channel_id, index)
+
+        while True:
+            frame = await self._read_audio_frame()
+            if frame is None:
+                break
+
+            self._write_pcm(wav, frame)
+            now = monotonic()
+
+            if self._is_speech(frame):
+                last_voice = now
+
+            # триггер 1: тишина достаточной длительности → финал всей реплики
+            if (now - last_voice) >= self.silence_timeout and (now - start_ts) >= self.min_rec_time:
+                path = self._finalize_wav(wav)
+                try:
+                    await on_chunk(path, True, index)
+                finally:
+                    self._close(wav)
+                return
+
+            # триггер 2: истекло окно → закрываем partial и продолжаем запись
+            if now >= deadline:
+                path = self._finalize_wav(wav)
+                try:
+                    await on_chunk(path, False, index)
+                finally:
+                    self._close(wav)
+                index += 1
+                wav = self._start_new_wav(channel_id, index, overlap_ms=self.chunk_overlap)
+                deadline = monotonic() + self.chunk_secs
+
+            # общий предохранитель всей реплики
+            if (now - start_ts) >= self.max_utt_time:
+                path = self._finalize_wav(wav)
+                try:
+                    await on_chunk(path, True, index)
+                finally:
+                    self._close(wav)
+                return
```

> В этом патче используются ваши существующие утилиты: `_start_new_wav(...)`, `_write_pcm(...)`, `_finalize_wav(...)`, `_read_audio_frame()`, `_is_speech(...)`. Они уже есть в проекте — вы просто подключаете новую стратегию записи.

---

# 4) `stasis_handler_optimized.py` — безопасный barge-in и вход “мягким окном”

```diff
--- a/stasis_handler_optimized.py
+++ b/stasis_handler_optimized.py
@@
-import asyncio, time, json, logging
+import os, asyncio, time, json, logging
 from typing import Dict, Any
@@
 class StasisHandlerOptimized:
     def __init__(self, ari, parallel_tts, filler_tts, asr, agent, log_store):
         self.ari = ari
         self.parallel_tts = parallel_tts
         self.filler_tts = filler_tts
         self.asr = asr
         self.agent = agent
         self.log_store = log_store
         self.logger = logging.getLogger(__name__)
-        self.active_calls: Dict[str, Dict[str, Any]] = {}
+        self.active_calls: Dict[str, Dict[str, Any]] = {}
+        # реестр playbacks для тотальной остановки (barge-in)
+        self.playback_events: Dict[str, Dict[str, Any]] = {}
+        # фичи/тайминги из env
+        self.use_soft_input = os.getenv("USE_SOFT_WINDOW_INPUT", "true").lower() == "true"
+        self.barge_in_enabled = os.getenv("BARGE_IN_ENABLED", "true").lower() == "true"
+        self.call_inactivity_timeout = int(os.getenv("CALL_INACTIVITY_TIMEOUT", "180"))
+        self.channel_monitor_interval = int(os.getenv("CHANNEL_MONITOR_INTERVAL", "60"))
@@
     async def on_event(self, event: Dict[str, Any]):
         et = event.get("type")
         # ... ваш существующий разбор событий ...
+        if et == "PlaybackStarted":
+            pid = event.get("playback", {}).get("id")
+            ch  = event.get("playback", {}).get("target_uri", "").split(":")[-1] or event.get("channel", {}).get("id")
+            if pid:
+                self.playback_events[pid] = {"channel_id": ch, "finished": False}
+                call = self.active_calls.setdefault(ch, {})
+                call["current_playback"] = pid
+                self.active_calls[ch] = call
+                self.logger.info(f"[ARI] PlaybackStarted id={pid} ch={ch}")
+        elif et == "PlaybackFinished":
+            pid = event.get("playback", {}).get("id")
+            ch  = event.get("playback", {}).get("target_uri", "").split(":")[-1] or event.get("channel", {}).get("id")
+            if pid and pid in self.playback_events:
+                self.playback_events[pid]["finished"] = True
+                if ch in self.active_calls and self.active_calls[ch].get("current_playback") == pid:
+                    self.active_calls[ch]["current_playback"] = None
+                self.logger.info(f"[ARI] PlaybackFinished id={pid} ch={ch}")
@@
-    async def stop_tts_on_barge_in_optimized(self, channel_id: str, event_name: str):
-        # было: чистили очереди, но не гасили реально проигрывания
-        if self.parallel_tts:
-            await self.parallel_tts.clear_all_queues(channel_id)
-        self.logger.info("Barge-in: queues cleared, ready for new input")
+    async def stop_tts_on_barge_in_optimized(self, channel_id: str, event_name: str):
+        if not self.barge_in_enabled:
+            return
+        self.logger.info(f"🚫 [BARGE-IN] {event_name} → stop all playbacks & queues (ch={channel_id})")
+        call = self.active_calls.get(channel_id, {})
+        # 1) текущий playback
+        current = call.get("current_playback")
+        if current:
+            try:
+                ok = await self.ari.stop_playback(current)
+                if ok:
+                    self.logger.info(f"🛑 Stopped current playback: {current}")
+            except Exception as e:
+                self.logger.warning(f"stop_playback error for {current}: {e}")
+            finally:
+                call["current_playback"] = None
+                self.active_calls[channel_id] = call
+        # 2) все незавершённые из реестра
+        active_pids = [pid for pid, meta in self.playback_events.items()
+                       if meta.get("channel_id") == channel_id and not meta.get("finished", True)]
+        for pid in active_pids:
+            try:
+                ok = await self.ari.stop_playback(pid)
+                if ok:
+                    self.logger.info(f"🛑 Force stopped playback: {pid}")
+                self.playback_events[pid]["finished"] = True
+            except Exception as e:
+                self.logger.warning(f"stop_playback error for {pid}: {e}")
+        # 3) очереди/таски tts
+        if self.parallel_tts:
+            await self.parallel_tts.clear_all_queues(channel_id)
+        # 4) флаги
+        call["user_interrupted"] = True
+        call["is_speaking"] = False
+        self.active_calls[channel_id] = call
+        self.logger.info("✅ Barge-in completed — ready for new input")
@@
-    async def _handle_user_speech(self, channel_id: str):
-        # старая логика: запись одним файлом
-        wav = await self.vad.record_until_silence(channel_id)
-        text = await self.asr.recognize_file(wav)
-        if not text:
-            return
-        await self._answer_user(channel_id, text)
+    async def _handle_user_speech(self, channel_id: str):
+        if not self.use_soft_input:
+            # совместимость со старым путем
+            wav = await self.vad.record_until_silence(channel_id)
+            text = await self.asr.recognize_file(wav)
+            if not text:
+                return
+            await self._answer_user(channel_id, text)
+            return
+
+        # новый путь: мягкое окно (квазистрим)
+        agg = []
+        first_prefetch = False
+
+        async def on_chunk(path: str, is_final: bool, index: int):
+            t = await self.asr.recognize_file(path)
+            if t:
+                agg.append(t)
+                self.logger.info(f"[ASR] chunk#{index} ({'final' if is_final else 'partial'}): {t}")
+            # префетч: после 1–2 кусочков запускаем агент заранее
+            nonlocal first_prefetch
+            if not is_final and not first_prefetch and len(" ".join(agg)) > 20:
+                first_prefetch = True
+                asyncio.create_task(self.agent.prefetch(channel_id, " ".join(agg)))
+
+        await self.vad.record_until_silence_with_soft_window(channel_id, on_chunk)
+        user_text = " ".join(agg).strip()
+        if not user_text:
+            return
+        await self._answer_user(channel_id, user_text)
```

---

# 5) (Опционально) `rtp.conf`/`asterisk.conf` — системные настройки низкой задержки

```diff
*** /dev/null
--- a/deploy/asterisk/rtp.conf.suggested
***************
+[general]
+rtpstart=10000
+rtpend=20000
+jitterbuffer=no
+rtp_timeout=30
+rtp_timeout_hold=60
+rtp_keepalive=20
```

```diff
*** /dev/null
--- a/deploy/asterisk/asterisk.conf.suggested
***************
+[options]
+transmit_silence=no
```

> Эти файлы — справочные “рекомендованные”. Примени по месту в своей установке Asterisk.

---

## Как применить

1. Сохрани все куски в файл, например `voice-fixes.patch`.
2. В корне репо:

   ```bash
   git checkout -b feature/voice-fixes
   git apply voice-fixes.patch
   git add -A
   git commit -m "Voice fixes: idempotent barge-in + soft-window input + env"
   ```
3. Пропиши значения в `.env` (или скопируй `env.example` → `.env`).
4. Перезапусти сервисы.
5. Протести по чек-листу:

   * длинная речь 20–30 с → режется на 5-сек. куски, бот **дослушивает**;
   * бардж-ин во время TTS → в логе `🛑 Stopped ...`, звук бота обрывается **мгновенно**;
   * короткие “Да/Нет” → улетают без лишней задержки;
   * простои не роняют звонок ранее `CALL_INACTIVITY_TIMEOUT`.

Если нужно — дополню патч блоком для клиентских параметров Yandex STT (`max_pause_between_words_hint_ms=2000`, `eou_classifier_options=HIGH`) в твоём `yandex_asr_service.py`.
